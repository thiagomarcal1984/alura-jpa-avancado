Para criar uma relação ManyToMany (com uma tabela intermediária e sem outros 
campos além dos ids das tabelas relacionadas), basta usar:

    // classe Pedido:
	@ManyToMany
	@JoinTable("itens_pedido") // Não obrigatório. Nomeia tabela intermediária.
	private List<Produto> produtos;

Como no exercício a tabela intermediária contém outros atributos (quantidade e
preço da venda na época), é necessário criar uma entidade à parte.

    Pedidos <- ItemPedido -> Produto

    Pedidos mapeia @OneToMany para ItemPedido.
    ItemPedido mapeia @ManyToOne (inverso) para Pedidos e para Produto.
    Produto não tem o mapeamento bidirecional, como Pedido/ItemPedido.

Cuidado ao definir mapeamentos bidirecionais. Senão, outras tabelas são criadas
sem necessidade (no exemplo, seria a tabela pedidos_itens_pedido). Para evitar
essa duplicidade de tabelas com mesma função, use o parâmetro mappedBy na
anotação do relacionamento:
    // Código da classe Pedido:
	@OneToMany(mappedBy = "pedido")
	private List<ItemPedido> produtos;
    // Onde "pedido" corresponde ao nome da variável que representa a  
    // propriedade privada na classe ItemPedido que se relaciona com a 
    // classe Pedido.

Uma boa prática: para cada definição de lista nas entidades, instancie uma
implementação da lista, para evitar Null Pointer Exceptions.

Ao inserir conteúdo de uma relação ManyToMany, crie um método em uma das 
classes para inserir os dois objetos relacionados:

	public void adicionarPedido(ItemPedido item) {
		item.setPedido(this);
		this.itens.add(item);
	}

É importante que tabelas com relacionamento ManyToMany tenham efeito cascata na
inserção/alteração/exclusão de itens. Para isso, acrescente o parâmetro cascade
na anotação OneToMany:
	@OneToMany(mappedBy = "pedido", cascade = CascadeType.ALL)
	private List<ItemPedido> itens = new ArrayList<>();

O nome das propriedades em cammelCase é substituido no banco de dados por 
snake_case nas entidades com relacionamento OneToMany ou ManyToOne. Isso não 
acontece no ManyToMany. As entidades que participam de um relacionamento 
ManyToMany precisam ter o nome da coluna redefinido para snake_case:

    // Classe ItemPedido
	@Column(name = "preco_unitario")
	private BigDecimal precoUnitario;

    // Classe Pedido
	@Column(name = "valor_total")
	private BigDecimal valorTotal;

A JPQL tem funções agregadas também (sum, avg, min, max etc.). Funções de 
agregação próprias do SGBD (se houverem) também podem ser usadas na JPQL:
	// classe PedidoDao
	public BigDecimal valorTotalVendido() {
		String jpql =  "SELECT SUM(p.valorTotal) FROM Pedido p";
		return em.createQuery(jpql, BigDecimal.class)
				.getSingleResult();
	}

No entanto, para que o resultado da consulta não seja nulo, o valor total do
pedido precisa ser atualizado sempre que um novo item de pedido for incluído:
	// A classe Pedido recupera o total do item...
	public void adicionarPedido(ItemPedido item) {
		item.setPedido(this);
		this.itens.add(item);
		this.valorTotal = valorTotal.add(item.getValor());
	}

	// ... e a classe ItemPedido calcula o total do item (quantidade x preço):
	public BigDecimal getValor() {
		return precoUnitario.multiply(new BigDecimal(quantidade));
	}

Como retornar resultados de JPQL com colunas de dados mistos: 
	1) Retornando uma lista com array de objetos (forma deselegante):
		public List<Object[]> relatorioDeVendas() {
			String jpql = "SELECT produto.nome, "
					+ "SUM(item.quantidade), "
					+ "MAX(pedido.data) "
					+ "FROM Pedido pedido "
					+ "JOIN pedido.itens item "
					+ "JOIN item.produto produto "
					+ "GROUP BY produto.nome "
					+ "ORDER BY item.quantidade DESC ";
			return em.createQuery(jpql, Object[].class)
					.getResultList();
		}

	2) Próxima aula vai explicar...
